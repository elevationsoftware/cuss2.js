<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: cuss2.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: cuss2.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>"use strict";
var __createBinding = (this &amp;&amp; this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this &amp;&amp; this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" &amp;&amp; !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Cuss2 = void 0;
const helper_1 = require("./helper");
const rxjs_1 = require("rxjs");
const applicationStates_1 = require("./interfaces/applicationStates");
var AppState = applicationStates_1.ApplicationStates.ApplicationStateCodeEnum;
var ChangeReason = applicationStates_1.ApplicationStates.ApplicationStateChangeReasonCodeEnum;
const connection_1 = require("./connection");
const component_1 = require("./models/component");
const cUSSDataTypes_1 = require("./interfaces/cUSSDataTypes");
const stateChange_1 = require("./models/stateChange");
const componentInterrogation_1 = require("./componentInterrogation");
const applicationActivation_1 = require("./interfaces/applicationActivation");
var ExecutionModeEnum = applicationActivation_1.ApplicationActivation.ExecutionModeEnum;
const { isAnnouncement, isFeeder, isDispenser, isBagTagPrinter, isBoardingPassPrinter, isDocumentReader, isBarcodeReader, isCardReader, isKeypad } = componentInterrogation_1.ComponentInterrogation;
/**
 * Helper function to validate if a componentID is a number
 * @param componentID
 * @throws {Error} - If the componentID is not a number
 */
function validateComponentId(componentID) {
    if (typeof componentID !== 'number') {
        throw new TypeError('Invalid componentID: ' + componentID);
    }
}
/**
 * Object used to connect to a CUSS 2 platform and to interact with it.
 * @class Cuss2
 */
class Cuss2 {
    /**
     * @param {Connection} connection - The connection object used to connect to the CUSS 2 platform.
     */
    constructor(connection) {
        this.environment = {};
        this.components = undefined;
        this.stateChange = new rxjs_1.BehaviorSubject(new stateChange_1.StateChange(AppState.STOPPED, AppState.STOPPED));
        this.componentStateChange = new rxjs_1.BehaviorSubject(null);
        this.onmessage = new rxjs_1.Subject();
        this.activated = new rxjs_1.Subject();
        this.deactivated = new rxjs_1.Subject();
        this.accessibleMode = false;
        this.api = {
            //
            // "GET" calls
            //
            getEnvironment: async () => {
                const response = await this.connection.get('/platform/environment');
                (0, helper_1.log)('verbose', '[getEnvironment()] response', response);
                this.environment = response.environmentLevel;
                return this.environment;
            },
            getComponents: async () => {
                const response = await this.connection.get('/platform/components');
                (0, helper_1.log)('verbose', '[getComponents()] response', response);
                const componentList = response.componentList;
                if (this.components)
                    return componentList;
                const components = this.components = {};
                //first find feeders &amp; dispensers so they can be linked when printers are created
                componentList.forEach((component) => {
                    const id = String(component.componentID);
                    let instance;
                    if (isFeeder(component))
                        instance = new component_1.Feeder(component, this);
                    else if (isDispenser(component))
                        instance = new component_1.Dispenser(component, this);
                    else
                        return;
                    return components[id] = instance;
                });
                componentList.forEach((component) => {
                    if (isFeeder(component))
                        return;
                    if (isDispenser(component))
                        return;
                    const id = String(component.componentID);
                    let instance;
                    if (isAnnouncement(component))
                        instance = this.announcement = new component_1.Announcement(component, this);
                    else if (isBagTagPrinter(component))
                        instance = this.bagTagPrinter = new component_1.BagTagPrinter(component, this);
                    else if (isBoardingPassPrinter(component))
                        instance = this.boardingPassPrinter = new component_1.BoardingPassPrinter(component, this);
                    else if (isDocumentReader(component))
                        instance = this.documentReader = new component_1.DocumentReader(component, this);
                    else if (isBarcodeReader(component))
                        instance = this.barcodeReader = new component_1.BarcodeReader(component, this);
                    else if (isCardReader(component))
                        instance = this.cardReader = new component_1.CardReader(component, this);
                    else if (isKeypad(component))
                        instance = this.keypad = new component_1.Keypad(component, this);
                    else
                        instance = new component_1.Component(component, this);
                    return components[id] = instance;
                });
                return componentList;
            },
            getStatus: async (componentID) => {
                const response = await this.connection.get('/peripherals/query/' + componentID);
                (0, helper_1.log)('verbose', '[queryDevice()] response', response);
                return response;
            },
            send: async (componentID, dataExchange) => {
                return this.connection.post('/peripherals/send/' + componentID, dataExchange);
            },
            setup: async (componentID, dataExchange) => {
                validateComponentId(componentID);
                return await this.connection.post('/peripherals/setup/' + componentID, dataExchange);
            },
            cancel: async (componentID) => {
                validateComponentId(componentID);
                return await this.connection.post('/peripherals/cancel/' + componentID);
            },
            /*
            *		/peripherals/userpresent/XXXXX
            */
            enable: async (componentID) => {
                validateComponentId(componentID);
                return await this.connection.post('/peripherals/userpresent/enable/' + componentID);
            },
            disable: async (componentID) => {
                validateComponentId(componentID);
                return await this.connection.post('/peripherals/userpresent/disable/' + componentID);
            },
            offer: async (componentID) => {
                validateComponentId(componentID);
                return await this.connection.post('/peripherals/userpresent/offer/' + componentID);
            },
            staterequest: async (state, reasonCode = ChangeReason.NOTAPPLICABLE, reason = '') => {
                if (this.pendingStateChange) {
                    return Promise.resolve(undefined);
                }
                (0, helper_1.log)("info", `Requesting ${state} state`);
                this.pendingStateChange = state;
                let response;
                try {
                    response = await this.connection.post('/platform/applications/staterequest', {
                        "applicationStateCode": state,
                        "applicationStateChangeReasonCode": reasonCode,
                        "applicationStateChangeReason": reason
                    })
                        .catch(e => {
                        // API is returning AL_APPLICATION_REQUEST instead of OK. Suppress it...
                        if (e.statusCode !== 'AL_APPLICATION_REQUEST') {
                            throw e;
                        }
                        return e;
                    });
                    return response;
                }
                finally {
                    this.pendingStateChange = undefined;
                }
            },
            /*
            *		/peripherals/announcement/XXXXX
            */
            announcement: {
                play: async (componentID, rawData) => {
                    validateComponentId(componentID);
                    const dataExchange = {
                        toPlatform: {
                            dataRecords: [{ data: rawData, dsTypes: [cUSSDataTypes_1.CUSSDataTypes.SSML10] }]
                        },
                    };
                    return await this.connection.post('/peripherals/announcement/play/' + componentID, dataExchange);
                },
                pause: async (componentID) => {
                    validateComponentId(componentID);
                    return await this.connection.post('/peripherals/announcement/pause/' + componentID);
                },
                resume: async (componentID) => {
                    validateComponentId(componentID);
                    return await this.connection.post('/peripherals/announcement/resume/' + componentID);
                },
                stop: async (componentID) => {
                    validateComponentId(componentID);
                    return await this.connection.post('/peripherals/announcement/stop/' + componentID);
                }
            }
        };
        this._online = false;
        this.connection = connection;
        connection.messages.subscribe(async (e) => await this._handleWebSocketMessage(e));
        connection.onclose.subscribe(async () => {
            await connection._connect();
            await this._initialize();
        });
    }
    static async connect(url, client_id, client_secret, options = {}) {
        const connection = await connection_1.Connection.connect(url, client_id, client_secret, options);
        const cuss2 = new Cuss2(connection);
        await cuss2._initialize();
        return cuss2;
    }
    get state() {
        return this.stateChange.getValue().current;
    }
    async _initialize() {
        (0, helper_1.log)("info", "Getting Environment Information");
        await this.api.getEnvironment();
        if (!this.state) {
            throw new Error('Platform in abnormal state.');
        }
        if (this.state === AppState.SUSPENDED) {
            throw new Error('Platform has SUSPENDED the application');
        }
        (0, helper_1.log)("info", "Getting Component List");
        await this.api.getComponents();
        await this.requestUnavailableState();
        this.queryComponents().catch(e => (0, helper_1.log)("error", 'error querying components', e));
    }
    async _handleWebSocketMessage(data) {
        const message = data &amp;&amp; data.toApplication;
        if (!message || message.statusCode === undefined)
            return; // initial value is an empty value
        (0, helper_1.log)('verbose', '[event.currentApplicationState]', message.currentApplicationState);
        const currentState = message.currentApplicationState?.toString();
        const unsolicited = !message.functionName;
        if (!currentState) {
            this.connection._socket?.close();
            throw new Error('Platform in invalid state. Cannot continue.');
        }
        if (currentState !== this.state) {
            const prevState = this.state;
            (0, helper_1.log)('verbose', `[state changed] old:${prevState} new:${currentState}`);
            this.stateChange.next(new stateChange_1.StateChange(prevState, currentState));
            if (this._online &amp;&amp; currentState === AppState.UNAVAILABLE) {
                await this.queryComponents().catch(e => (0, helper_1.log)('verbose', 'failed to queryComponents', e));
                this.checkRequiredComponentsAndSyncState();
            }
            else if (currentState === AppState.ACTIVE) {
                this.multiTenant = message.applicationActivation?.executionMode === ExecutionModeEnum.MAM;
                this.accessibleMode = message.applicationActivation?.accessibleMode || false;
                this.language = message.applicationActivation?.languageID;
                this.activated.next();
            }
            if (prevState === AppState.ACTIVE) {
                this.deactivated.next(currentState);
            }
        }
        if (typeof message.componentID === 'number' &amp;&amp; this.components) {
            const component = this.components[message.componentID];
            if (component &amp;&amp; component.stateIsDifferent(message)) {
                component.updateState(message);
                this.componentStateChange.next(component);
                if (unsolicited || message.functionName === 'query') {
                    this.checkRequiredComponentsAndSyncState();
                }
            }
        }
        (0, helper_1.log)('verbose', "[socket.onmessage]", message);
        this.onmessage.next(message);
    }
    //
    // State requests. Only offer the ones that are valid to request.
    //
    async requestAvailableState() {
        // allow hoping directly to AVAILABLE from INITIALIZE
        if (this.state === AppState.INITIALIZE) {
            await this.requestUnavailableState();
        }
        const okToChange = this.state === AppState.UNAVAILABLE || this.state === AppState.ACTIVE;
        return okToChange ? this.api.staterequest(AppState.AVAILABLE) : Promise.resolve(undefined);
    }
    requestUnavailableState() {
        const okToChange = this.state === AppState.INITIALIZE || this.state === AppState.AVAILABLE || this.state === AppState.ACTIVE;
        return okToChange ? this.api.staterequest(AppState.UNAVAILABLE) : Promise.resolve(undefined);
    }
    requestStoppedState() {
        return this.api.staterequest(AppState.STOPPED);
    }
    requestActiveState() {
        const okToChange = this.state === AppState.AVAILABLE || this.state === AppState.ACTIVE;
        return okToChange ? this.api.staterequest(AppState.ACTIVE) : Promise.resolve(undefined);
    }
    async requestReload() {
        const okToChange = !this.state || this.state === AppState.UNAVAILABLE || this.state === AppState.AVAILABLE || this.state === AppState.ACTIVE;
        if (!okToChange) {
            return Promise.resolve(false);
        }
        await this.api.staterequest(AppState.RELOAD);
        this.connection._socket?.close();
        return true;
    }
    async queryComponents() {
        if (!this.components) {
            return false;
        }
        const componentList = Object.values(this.components);
        await Promise.all(componentList.map(c => c.query()
            .catch(e => e)) //it rejects statusCodes that are not "OK" - but here we just need to know what it is, so ignore
        );
        return true;
    }
    get unavailableComponents() {
        const components = Object.values(this.components);
        return components.filter((c) => !c.ready);
    }
    get unavailableRequiredComponents() {
        return this.unavailableComponents.filter((c) => c.required);
    }
    checkRequiredComponentsAndSyncState() {
        if (this.pendingStateChange)
            return;
        if (this._online) {
            const inactiveRequiredComponents = this.unavailableRequiredComponents;
            if (!inactiveRequiredComponents.length) {
                if (this.state === AppState.UNAVAILABLE) {
                    (0, helper_1.log)('verbose', '[checkRequiredComponentsAndSyncState] All required components OK ✅. Ready for AVAILABLE state.');
                    this.requestAvailableState();
                }
            }
            else {
                (0, helper_1.log)('verbose', '[checkRequiredComponentsAndSyncState] Required components UNAVAILABLE:', inactiveRequiredComponents.map((c) => c.constructor.name));
                this.requestUnavailableState();
            }
        }
        else if (this.components) {
            this.requestUnavailableState();
        }
    }
    get applicationOnline() { return this._online; }
    set applicationOnline(online) {
        this._online = online;
        this.checkRequiredComponentsAndSyncState();
    }
}
exports.Cuss2 = Cuss2;
Cuss2.log = helper_1.log;
Cuss2.logger = helper_1.logger;
Cuss2.helpers = helper_1.helpers;
__exportStar(require("./models/component"), exports);
__exportStar(require("./models/stateChange"), exports);
__exportStar(require("./helper"), exports);
__exportStar(require("./componentInterrogation"), exports);
//# sourceMappingURL=cuss2.js.map</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Cuss2.html">Cuss2</a></li></ul><h3>Global</h3><ul><li><a href="global.html#validateComponentId">validateComponentId</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.10</a> on Tue Jan 25 2022 11:58:02 GMT-0700 (Mountain Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
